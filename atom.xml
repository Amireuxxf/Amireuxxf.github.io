<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵小航</title>
  
  <subtitle>时光停滞,岁月静好</subtitle>
  <link href="https://amireuxxf.github.io/atom.xml" rel="self"/>
  
  <link href="https://amireuxxf.github.io/"/>
  <updated>2022-09-05T03:55:44.614Z</updated>
  <id>https://amireuxxf.github.io/</id>
  
  <author>
    <name>赵小航</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="https://amireuxxf.github.io/posts/4a098468/"/>
    <id>https://amireuxxf.github.io/posts/4a098468/</id>
    <published>2022-09-05T00:41:58.000Z</published>
    <updated>2022-09-05T03:55:44.614Z</updated>
    
    
    <summary type="html">MarkDown语法</summary>
    
    
    
    
    <category term="MarkDown" scheme="https://amireuxxf.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>GitHub加速</title>
    <link href="https://amireuxxf.github.io/posts/7b72b0de/"/>
    <id>https://amireuxxf.github.io/posts/7b72b0de/</id>
    <published>2022-08-31T03:24:33.000Z</published>
    <updated>2022-08-31T07:46:15.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>&emsp;&emsp;GitHub想必大家都不陌生吧，它是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。</p><p>&emsp;&emsp;GitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目Ruby on Rails、jQuery、Python等。</p><p>&emsp;&emsp;GitHub因其强大的代码托管功能受到广大程序员的信赖，但因其服务器在国外，国内使用过GitHub的小伙伴一定遇到过这种情况</p><p><img src="/img/GitHub%E8%AE%BF%E9%97%AE%E9%94%99%E8%AF%AF.png" alt="GitHub访问错误"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>&emsp;&emsp;这里给大家提供几种本人亲自测试过的解决方案，以供大家选择。</p><h3 id="方案一：Github镜像源"><a href="#方案一：Github镜像源" class="headerlink" title="方案一：Github镜像源"></a>方案一：Github镜像源</h3><p>&emsp;&emsp;1.<a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a></p><p>&emsp;&emsp;2.<a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p><p>&emsp;&emsp;3.<a href="https://github.wuyanzheshui.workers.dev/">https://github.wuyanzheshui.workers.dev/</a></p><h3 id="方案二：dev-sidecar"><a href="#方案二：dev-sidecar" class="headerlink" title="方案二：dev-sidecar"></a>方案二：dev-sidecar</h3><p>&emsp;&emsp;开发者边车，命名取自service-mesh的service-sidecar，意为为开发者打辅助的边车工具 通过本地代理的方式将https请求代理到一些国内的加速通道上</p><p>&emsp;&emsp;下载地址：<a href="https://gitee.com/interesting-goods/dev-sidecar?_from=gitee_search">https://gitee.com/interesting-goods/dev-sidecar?_from=gitee_search</a></p><h3 id="方案三：修改Host地址"><a href="#方案三：修改Host地址" class="headerlink" title="方案三：修改Host地址"></a>方案三：修改Host地址</h3><p>&emsp;&emsp;可以查询<a href="https://github.com.ipaddress.com/#ipinfo%E7%9A%84IP%E5%9C%B0%E5%9D%80">https://github.com.ipaddress.com/#ipinfo的IP地址</a></p><p><img src="/img/20210509084840985.png" alt="20210509084840985"></p><p>&emsp;&emsp;以及<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo%EF%BC%8C">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo，</a></p><p><img src="/img/20210509084809134.png" alt="20210509084809134"></p><p>&emsp;&emsp;在Host文件的最后加上如下内容（Host文件一般在“C(系统盘):\Windows\System32\drivers\etc”文件夹下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#github</span><br><span class="line">140.82.112.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更改完成后，打开命令提示符（cmd），刷新DNS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><h3 id="方案四：FastGithub-推荐"><a href="#方案四：FastGithub-推荐" class="headerlink" title="方案四：FastGithub(推荐)"></a>方案四：FastGithub(推荐)</h3><p>github加速神器，解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题。</p><h4 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h4><ul><li><strong>fastgithub不具备“翻墙”功能,也没有相关的计划</strong></li><li><strong>fastgithub不支持Windows7等已被发行方停止支持的操作系统，并且也不会主动提供支持</strong></li><li><strong>fastgithub不能为您的游戏加速</strong></li><li><strong>fastgithub没有主动在github和<a href="mailto:fastgithub@qq.com">fastgithub@qq.com</a>之外的任何渠道发布</strong></li></ul><h4 id="1-程序下载"><a href="#1-程序下载" class="headerlink" title="1 程序下载"></a>1 程序下载</h4><ul><li><a href="https://github.com/dotnetcore/fastgithub/releases">github-release下载</a></li><li>发送任意邮件到<a href="mailto:fastgithub@qq.com">fastgithub@qq.com</a></li></ul><h4 id="2-部署方式"><a href="#2-部署方式" class="headerlink" title="2 部署方式"></a>2 部署方式</h4><h5 id="2-1-windows-x64桌面"><a href="#2-1-windows-x64桌面" class="headerlink" title="2.1 windows-x64桌面"></a>2.1 windows-x64桌面</h5><ul><li>双击运行FastGithub.UI.exe</li></ul><h5 id="2-2-windows-x64服务"><a href="#2-2-windows-x64服务" class="headerlink" title="2.2 windows-x64服务"></a>2.2 windows-x64服务</h5><ul><li><code>fastgithub.exe start</code> // 以windows服务安装并启动</li><li><code>fastgithub.exe stop</code> // 以windows服务卸载并删除</li></ul><h5 id="2-3-linux-x64终端"><a href="#2-3-linux-x64终端" class="headerlink" title="2.3 linux-x64终端"></a>2.3 linux-x64终端</h5><ul><li><code>sudo ./fastgithub</code></li><li>设置系统自动代理为<code>http://127.0.0.1:38457</code>，或手动代理http/https为<code>127.0.0.1:38457</code></li></ul><h5 id="2-4-linux-x64服务"><a href="#2-4-linux-x64服务" class="headerlink" title="2.4 linux-x64服务"></a>2.4 linux-x64服务</h5><ul><li><code>sudo ./fastgithub start</code> // 以systemd服务安装并启动</li><li><code>sudo ./fastgithub stop</code> // 以systemd服务卸载并删除</li><li>设置系统自动代理为<code>http://127.0.0.1:38457</code>，或手动代理http/https为<code>127.0.0.1:38457</code></li></ul><h5 id="2-5-macOS-x64"><a href="#2-5-macOS-x64" class="headerlink" title="2.5 macOS-x64"></a>2.5 macOS-x64</h5><ul><li>双击运行fastgithub</li><li>安装cacert/fastgithub.cer并设置信任</li><li>设置系统自动代理为<code>http://127.0.0.1:38457</code>，或手动代理http/https为<code>127.0.0.1:38457</code></li><li><a href="https://github.com/dotnetcore/FastGithub/blob/master/MacOSXConfig.md">具体配置详情</a></li></ul><h5 id="2-6-docker-compose一键部署"><a href="#2-6-docker-compose一键部署" class="headerlink" title="2.6 docker-compose一键部署"></a>2.6 docker-compose一键部署</h5><ul><li>准备好docker 18.09, docker-compose.</li><li>在源码目录下，有一个docker-compose.yaml 文件，专用于在实际项目中，临时使用github.com源码，而做的demo配置。</li><li>根据自己的需要更新docker-compose.yaml中的sample和build镜像即可完成拉github.com源码加速，并基于源码做后续的操作。</li></ul><h4 id="3-软件功能"><a href="#3-软件功能" class="headerlink" title="3 软件功能"></a>3 软件功能</h4><ul><li>提供域名的纯净IP解析；</li><li>提供IP测速并选择最快的IP；</li><li>提供域名的tls连接自定义配置；</li><li>google的CDN资源替换，解决大量国外网站无法加载js和css的问题；</li></ul><h4 id="4-证书验证"><a href="#4-证书验证" class="headerlink" title="4 证书验证"></a>4 证书验证</h4><h5 id="4-1-git"><a href="#4-1-git" class="headerlink" title="4.1 git"></a>4.1 git</h5><p>git操作提示<code>SSL certificate problem</code><br>需要关闭git的证书验证：<code>git config --global http.sslverify false</code></p><h5 id="4-2-firefox"><a href="#4-2-firefox" class="headerlink" title="4.2 firefox"></a>4.2 firefox</h5><p>firefox提示<code>连接有潜在的安全问题</code><br>设置-&gt;隐私与安全-&gt;证书-&gt;查看证书-&gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”</p><h4 id="5-安全性说明"><a href="#5-安全性说明" class="headerlink" title="5 安全性说明"></a>5 安全性说明</h4><p>FastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。</p><h4 id="6-合法性说明"><a href="#6-合法性说明" class="headerlink" title="6 合法性说明"></a>6 合法性说明</h4><p>《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。</p>]]></content>
    
    
    <summary type="html">GitHub加速访问</summary>
    
    
    
    
    <category term="教程" scheme="https://amireuxxf.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>赵小航</title>
    <link href="https://amireuxxf.github.io/posts/a60727c/"/>
    <id>https://amireuxxf.github.io/posts/a60727c/</id>
    <published>2022-08-30T13:22:26.000Z</published>
    <updated>2022-09-05T01:58:20.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h4><p>&emsp;&emsp;Hello,你好呀！我是程序员赵小航，是一名刚入行的程序员小白。熟悉HTML，CSS，JavaScript以及TypeScript等编程语言，目前正在系统的进行Java后端方向的学习，目标是成为全栈开发工程师，快来和我一起交流学习，共同进步吧！</p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub:"></a>GitHub:</h4><p>&emsp;&emsp;<a href="https://github.com/Amireuxxf">https://github.com/Amireuxxf</a></p><h4 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee:"></a>Gitee:</h4><p>&emsp;&emsp;<a href="https://gitee.com/Amireuxxf">https://gitee.com/Amireuxxf</a></p><h4 id="MyBlog"><a href="#MyBlog" class="headerlink" title="MyBlog:"></a>MyBlog:</h4><p>&emsp;&emsp;<a href="https://amireuxxf.cn/">https://amireuxxf.cn/</a></p>]]></content>
    
    
    <summary type="html">个人简介</summary>
    
    
    
    
    <category term="个人简介" scheme="https://amireuxxf.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>npm安装依赖报错</title>
    <link href="https://amireuxxf.github.io/posts/4dbbe0bc/"/>
    <id>https://amireuxxf.github.io/posts/4dbbe0bc/</id>
    <published>2022-08-30T13:01:47.000Z</published>
    <updated>2022-09-01T12:41:51.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在仓库上拉取项目，安装依赖时报错："><a href="#在仓库上拉取项目，安装依赖时报错：" class="headerlink" title="在仓库上拉取项目，安装依赖时报错："></a>在仓库上拉取项目，安装依赖时报错：</h4><p>&emsp; npm报错：npm ERR! code ECONNREFUSED npm ERR! errno ECONNREFUSED，npm ERR! npm ERR! If you are behind a proxy, please make sure that the</p><h4 id="问题出现原因："><a href="#问题出现原因：" class="headerlink" title="问题出现原因："></a>问题出现原因：</h4><p>&emsp;Github相当于程序员的百度，但是速度有时又太慢，就使用了某VPN代理访问。结果，VPN开了一个端口，npm的一些依赖包访问速度巨慢，就出现了报错</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><h5 id="查看代理"><a href="#查看代理" class="headerlink" title="查看代理"></a>查看代理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get proxy</span><br><span class="line">npm config get https-proxy</span><br></pre></td></tr></table></figure><p>如果发现有代理，就清空它</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h5 id="全局配置淘宝镜像"><a href="#全局配置淘宝镜像" class="headerlink" title="全局配置淘宝镜像"></a>全局配置淘宝镜像</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure><p>再安装依赖就OK了</p></li></ol>]]></content>
    
    
    <summary type="html">技术教程</summary>
    
    
    
    
    <category term="技术教程" scheme="https://amireuxxf.github.io/tags/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GET请求与POST请求的本质区别</title>
    <link href="https://amireuxxf.github.io/posts/b7e07608/"/>
    <id>https://amireuxxf.github.io/posts/b7e07608/</id>
    <published>2022-08-30T12:31:49.000Z</published>
    <updated>2022-09-02T06:16:53.632Z</updated>
    
    <content type="html"><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p><ul><li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。<br>（本标准答案参考自w3schools）<br>“很遗憾，这不是我们要的回答！”</li></ul><p>&emsp;&emsp;请告诉我真相。。。<br>&emsp;&emsp;如果我告诉你GET和POST本质上没有区别你信吗？让我们扒下GET和POST的外衣，坦诚相见吧！</p><p>&emsp;&emsp;GET和POST是什么？HTTP协议中的两种发送请求的方法。<br>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。<br>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。<br>那么，“标准答案”里的那些区别是怎么回事？</p><p>&emsp;&emsp;在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。</p><p>&emsp;&emsp;为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。<br>当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。<br>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p><p>&emsp;&emsp;在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>&emsp;&emsp;我们的大BOSS还等着出场呢。。。这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>&emsp;&emsp;而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>&emsp;&emsp;也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ol>]]></content>
    
    
    <summary type="html">信息技术</summary>
    
    
    
    
    <category term="信息技术" scheme="https://amireuxxf.github.io/tags/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点-SE篇</title>
    <link href="https://amireuxxf.github.io/posts/9b28f329/"/>
    <id>https://amireuxxf.github.io/posts/9b28f329/</id>
    <published>2022-08-22T04:05:56.000Z</published>
    <updated>2022-08-30T11:56:06.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面向对象特性？"><a href="#1-面向对象特性？" class="headerlink" title="1.面向对象特性？"></a>1.面向对象特性？</h3><ul><li><strong>封装</strong><br>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。<br>优点:<ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li><li><strong>继承</strong><br>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。<br>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</li><li><strong>多态</strong><br>多态分为编译时多态和运行时多态:</li><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件:</li><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul></li></ul><h3 id="2-对equals-和hashCode-的理解"><a href="#2-对equals-和hashCode-的理解" class="headerlink" title="2.对equals()和hashCode()的理解?"></a>2.对equals()和hashCode()的理解?</h3><ul><li><strong>为什么在重写 equals 方法的时候需要重写 hashCode 方法</strong>?<br>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</li><li><strong>有没有可能两个不相等的对象有相同的 hashcode</strong>?<br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</li><li><strong>两个相同的对象会有不同的 hash code 吗</strong>?<br>不能，根据 hash code 的规定，这是不可能的。</li></ul><h3 id="3-String、StringBuffer与StringBuilder的区别？"><a href="#3-String、StringBuffer与StringBuilder的区别？" class="headerlink" title="3.String、StringBuffer与StringBuilder的区别？"></a>3.String、StringBuffer与StringBuilder的区别？</h3><ul><li>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</li><li>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</li></ul><h3 id="4-接口与抽象类的区别？"><a href="#4-接口与抽象类的区别？" class="headerlink" title="4.接口与抽象类的区别？"></a>4.接口与抽象类的区别？</h3><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li><li>抽象类可以有构造方法, 接口没有构造方法</li><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li></ul><h3 id="5-this-amp-super-在构造方法中的区别？"><a href="#5-this-amp-super-在构造方法中的区别？" class="headerlink" title="5.this() &amp; super()在构造方法中的区别？"></a>5.this() &amp; super()在构造方法中的区别？</h3><ul><li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li><li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li><li>尽管可以用this调用一个构造器, 却不能调用2个</li><li>this和super不能出现在同一个构造器中, 否则编译不通过</li><li>this()、super()都指的对象,不可以在static环境中使用</li><li>本质this指向本对象的指针。super是一个关键字</li></ul><h3 id="6-Break和continue和return有什么区别？"><a href="#6-Break和continue和return有什么区别？" class="headerlink" title="6.Break和continue和return有什么区别？"></a>6.Break和continue和return有什么区别？</h3><ul><li>break是结束循环。</li><li>continue是跳过本次循环，执行下一次循环。</li><li>return的作用不是结束循环，而是结束方法。</li></ul><h3 id="7-什么是方法重载（Overload）方法重写（Override）？"><a href="#7-什么是方法重载（Overload）方法重写（Override）？" class="headerlink" title="7.什么是方法重载（Overload）方法重写（Override）？"></a>7.什么是方法重载（Overload）方法重写（Override）？</h3><ul><li>方法重载：在同一个类中，具有相同的方法名， 参数列表不同（参数的个数及类型不同），与返回值无关。</li><li>方法重写：在子类中出现与父类一模一样的方法，返回值类型，方法名和参数列表都相同，会出现覆盖的效果，叫做方法的重写或复写。（声明不变，重新实现）</li></ul><h3 id="8-选择排序，冒泡排序原理？"><a href="#8-选择排序，冒泡排序原理？" class="headerlink" title="8.选择排序，冒泡排序原理？"></a>8.选择排序，冒泡排序原理？</h3><ul><li>选择排序：用第一个元素和每一个元素进行比较，从0索引开始，依次和后面元素比较，小的放前面，第一次完毕，最小值出现在最小索引处。</li><li>冒泡排序：相邻元素两两比较，大的往后放，第一次比较结束，最大值出现在最大索引处。</li></ul><h3 id="9-Java中继承的特点？"><a href="#9-Java中继承的特点？" class="headerlink" title="9.Java中继承的特点？"></a>9.Java中继承的特点？</h3><ul><li>java只能单继承不能多继承但可以多层继承，即间接继承；</li><li>子类默认拥有父类所有的非私有成员变量及方法；</li><li>一个类只能有一个父类，但一个父类可以有多个子类。</li></ul><h3 id="10-继承中成员变量、成员方法如何访问？"><a href="#10-继承中成员变量、成员方法如何访问？" class="headerlink" title="10.继承中成员变量、成员方法如何访问？"></a>10.继承中成员变量、成员方法如何访问？</h3><ul><li>子类可以直接访问父类中的非私有成员变量和方法；</li><li>出现同名的成员变量或方法时，在子类要访问父类的非私有成员变量或方法需要用 super引用；</li><li>构造方法不会被继承，子类初始化对象数据时一定会先调用父类的无参构造。</li></ul><h3 id="11-多态的好处和弊端（如何解决）？"><a href="#11-多态的好处和弊端（如何解决）？" class="headerlink" title="11.多态的好处和弊端（如何解决）？"></a>11.多态的好处和弊端（如何解决）？</h3><ul><li>好处：提高程序的扩展性，有更好的维护性（增加新子类不影响已存在类的多态性、继承性及其他操作）</li><li>弊端：不能使用子类特有的成员。</li><li>解决弊端：向下转型。</li></ul><h3 id="12-静态代码块的特点？"><a href="#12-静态代码块的特点？" class="headerlink" title="12.静态代码块的特点？"></a>12.静态代码块的特点？</h3><ul><li>给类变量（静态变量）进行初始化赋值</li><li>随着类的加载而执行且只执行一次，并且优先级高于main方法和构造方法。</li></ul><h3 id="13-静态成员变量和成员变量的区别？"><a href="#13-静态成员变量和成员变量的区别？" class="headerlink" title="13.静态成员变量和成员变量的区别？"></a>13.静态成员变量和成员变量的区别？</h3><ul><li>所属不同。静态成员变量属于类，成员变量属于对象。</li><li>内存位置不同。静态成员变量存在于静态区，成员变量存在于堆内存。</li><li>内存出现时间不同。静态成员变量随着类的加载而加载，且只加载一次，成员变量随对象的创建而存在。</li><li>调用不同。静态成员变量可以被类和对象调用，成员变量只能被对象调用。</li></ul><h3 id="14-多态的前提？"><a href="#14-多态的前提？" class="headerlink" title="14.多态的前提？"></a>14.多态的前提？</h3><ul><li>要有继承或实现关系</li><li>要有方法的重写</li><li>要有父类引用指向子类对象</li></ul><h3 id="15-throws和throw的区别？"><a href="#15-throws和throw的区别？" class="headerlink" title="15.throws和throw的区别？"></a>15.throws和throw的区别？</h3><ul><li>throw代表抛出一个异常的动作，throws代表可能有异常抛出的一种状态。</li><li>throw用在方法实现中，throws用在方法声明中。</li><li>throw只能用于抛出一种异常，throws可以抛出多个异常。</li></ul><h3 id="16-Finally有什么特点？"><a href="#16-Finally有什么特点？" class="headerlink" title="16.Finally有什么特点？"></a>16.Finally有什么特点？</h3><ul><li>在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</li><li>finally不能单独使用。必须配合着try…catch使用。</li><li>如果catch中有return语句，先执行finally中的代码，再执行return语句。</li></ul><h3 id="17-List集合有什么特点？List有3个子类，特点？"><a href="#17-List集合有什么特点？List有3个子类，特点？" class="headerlink" title="17.List集合有什么特点？List有3个子类，特点？"></a>17.List集合有什么特点？List有3个子类，特点？</h3><ul><li>有序可重复</li><li>ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高。</li><li>LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高。</li><li>Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低。</li></ul><h3 id="18-数组和集合有什么区别？"><a href="#18-数组和集合有什么区别？" class="headerlink" title="18.数组和集合有什么区别？"></a>18.数组和集合有什么区别？</h3><ul><li>数组长度固定，集合长度可变。</li><li>数组存储同一类型的元素，可以存储基本数据类型值。</li><li>集合存储的是对象，类型可以不一致，不能存放基本数据类型。</li></ul><h3 id="19-Final-finally，finalize区别？"><a href="#19-Final-finally，finalize区别？" class="headerlink" title="19.Final finally，finalize区别？"></a>19.Final finally，finalize区别？</h3><ul><li>final:是修饰符，修饰类，类不能被继承；修饰变量，不能被重新赋值，变成常量；修饰方法，方法不能被重写。</li><li>finally:是异常处理的一部分，用于释放资源。finally中的代码一定会被执行，特殊情况，在执行finally之前jvm退出。</li><li>finalize:是object类的一个方法，用于垃圾回收。</li></ul><h3 id="20-HashSet如何保证数据唯一性？"><a href="#20-HashSet如何保证数据唯一性？" class="headerlink" title="20.HashSet如何保证数据唯一性？"></a>20.HashSet如何保证数据唯一性？</h3><ul><li>通过hashCode()和equals()方法</li><li>先看hashCode()值是否相同</li><li>相同：继续equals()方法，<br>返回true：元素重复，不添加；<br>返回false：元素不重复，添加</li><li>不同：直接添加</li></ul><h3 id="21-hashMap和hashTable的区别？"><a href="#21-hashMap和hashTable的区别？" class="headerlink" title="21.hashMap和hashTable的区别？"></a>21.hashMap和hashTable的区别？</h3><ul><li>hashMap：线程不安全，效率高，允许null键和null值。</li><li>hashTable：线程安全，效率低，不允许null键和null值。</li></ul><h3 id="22-Collection-和-collections有什么区别？"><a href="#22-Collection-和-collections有什么区别？" class="headerlink" title="22.Collection 和 collections有什么区别？"></a>22.Collection 和 collections有什么区别？</h3><ul><li>collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法，collection接口在Java类库中有很多具体的体现，意义是为各种具体的集合提供了最大化的统一操作方式。</li><li>collections是一个操作集合的工具类，包含各种有关集合操作的静态多态方法，不能实例化，服务于Java的collection框架。</li></ul><h3 id="23-什么是递归？写递归要注意什么？"><a href="#23-什么是递归？写递归要注意什么？" class="headerlink" title="23.什么是递归？写递归要注意什么？"></a>23.什么是递归？写递归要注意什么？</h3><ul><li>递归是在自己的方法内调用自己。</li><li>递归一定要有条件限制，保证递归能够停止，否则会发生栈内存溢出。</li><li>递归次数不能太多，否则也会发生栈内存溢出。</li><li>构造方法禁止递归，构造方法是创建对象使用的，不能让对象一直创建下去。</li></ul><h3 id="24-和-eques的区别？"><a href="#24-和-eques的区别？" class="headerlink" title="24.== 和 eques的区别？"></a>24.== 和 eques的区别？</h3><ul><li>==是运算符，如果是基本数据类型，比较存储的值，如果是引用数据类型，比较所指对象的地址值（是否为同一个类）。</li><li>equals是object的方法，比较所指对象的地址值，重写之后比较对象的值。</li></ul><h3 id="25-IO流中的flush和close有什么区别？"><a href="#25-IO流中的flush和close有什么区别？" class="headerlink" title="25.IO流中的flush和close有什么区别？"></a>25.IO流中的flush和close有什么区别？</h3><ul><li>close();关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可以继续使用。</li><li>flush();仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。</li></ul><h3 id="26-Thread类和runable接口有什么区别？"><a href="#26-Thread类和runable接口有什么区别？" class="headerlink" title="26.Thread类和runable接口有什么区别？"></a>26.Thread类和runable接口有什么区别？</h3><ul><li>Runnable接口可以避免单继承的局限性，具有较强的健壮性。</li><li>Runnable可以实现资源的共享，同时处理同一资源。</li><li>Thread类的线程间都是独立运行的，资源不共享。</li><li>继承Thread类不再被其他类继承（Java不存在多继承）</li></ul><h3 id="27-什么是线程安全？如何判断一个程序是否会出现线程安全呢？"><a href="#27-什么是线程安全？如何判断一个程序是否会出现线程安全呢？" class="headerlink" title="27.什么是线程安全？如何判断一个程序是否会出现线程安全呢？"></a>27.什么是线程安全？如何判断一个程序是否会出现线程安全呢？</h3><ul><li>多线程执行的结果和单线程运行的结果一样，就是线程安全的。</li><li>是否有共享资源   是</li><li>是否有多条执行路径   是</li><li>是否这多条路径操作共享资源   是</li></ul>]]></content>
    
    
    <summary type="html">知识点整理</summary>
    
    
    
    
    <category term="信息技术" scheme="https://amireuxxf.github.io/tags/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>我拒绝向岁月祈求-贾平凹</title>
    <link href="https://amireuxxf.github.io/posts/ddfda2a8/"/>
    <id>https://amireuxxf.github.io/posts/ddfda2a8/</id>
    <published>2022-08-20T09:03:59.000Z</published>
    <updated>2022-08-30T13:23:31.278Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;行走于世间，接纳或拒绝，爱或不爱，放弃或执著…… 每个人都应有接纳与宽容之心，但也要学会拒绝。 </p><p>&emsp;&emsp;我拒绝麻木。虽然生活的磨砺让太多的热情化做烟云，但不能让感情磨出老茧。如果没有云让眼神放飞追逐，那么生还有什么乐趣？ </p><p>&emsp;&emsp;我拒绝永远明媚的日子。因为那是虚幻的梦境，痛苦可以让我成长、让我坚强。生活中的阴雨与风雪使我能清醒地在春梦中看清脚下的路。</p><p>&emsp;&emsp;我拒绝折下那朵盛开的小花，那是在毁灭美的生命。一枝脆弱的纤细花茎，经过多少挣扎与痛苦才盛开出美丽，怎忍心为个人的私欲而去毁灭别人的幸福。我只求远远地望着，默默祈祷那自然的奇迹开遍人生的每个角落。</p><p>&emsp;&emsp;我拒绝用青春去赌明天。那弥足珍贵的季节，怎能经得起一掷千金，千金可以收回，但无论是一小时、一分钟……失去了便无处可寻了。青春属于自己，把握它，运用它，珍惜它，才能收获金秋的硕果。 </p><p>&emsp;&emsp;我拒绝成为那窗台上惧怕风雨的温柔花，它们只能隔着玻璃窗，感叹多变的天气。有朝一日，有风从虚掩的窗户掠过，那娇弱的花朵便瓣瓣凋零，落一地遗憾和伤心。 </p><p>&emsp;&emsp;我欣赏那些与男人并肩的女性，凭自己的聪慧和魅力，得到世界的尊重和生活的地位。我欣赏那有几分豪气的女人，靠自己的双肩挑起生活重担，出得厅堂，下得厨房，卷起袖子能杀鸡宰羊，却也有万缕柔肠能营造一片温馨。 </p><p>&emsp;&emsp;我拒绝生活中的痛苦，虽然我无力去阻挡要降临的事。 </p><p>&emsp;&emsp;曾听过一个故事：有人去找禅师求得解脱痛苦的方法，禅师让他自己去悟。第一天，禅师问他悟到什么，他不知，便举起戒尺打他一下。第二天，禅师又问，他仍不知，禅师举起戒尺又打了他一下。第三天他仍然没有收获，当禅师举手要打时，他却挡住了。于是禅师笑道：“你终于悟出了这道理——拒绝痛苦。”</p><p>&emsp;&emsp;我拒绝为满足虚荣、得到金钱与地位而不惜以青春、美丽甚至感情为祭品。人生中充满诱惑，也同样遍布着歧途与陷阱，女人的美丽是自然的恩赐，是真、善、美的化身，宛如一块无瑕的美玉，决不能被世俗污染，女人要靠自己的能力与才智取得应有的地位和尊重。</p><p>&emsp;&emsp;我拒绝倾听罗密欧与朱丽叶式的故事。虽然他们爱得壮烈，但终究是悲剧的结局。我只求现实中的爱有一点浪漫，有几缕微风，有短暂的雷雨也无妨，始终是平淡而幸福的喜剧。</p><p>&emsp;&emsp;我拒绝向岁月祈求，流着泪埋怨时光的无情。</p><p>&emsp;&emsp;虽然，青春已无声地在日历中一页页翻飞不见了，生活已把经历写在我的眼角，染白长长的青丝，但我相信女人的青春在于她的心境。美丽易逝，魅力永存。 </p><p>&emsp;&emsp;我拒绝目的明确的爱情。爱是无法用语言说明的，一段让人辗转难眠、牵肠挂肚、见面时又相对无言的情感遭遇，经过多少欢笑与泪水、缠绵与零落，只为表达一个难以启齿的字——爱。我喜欢平静地望着爱人眼中的自己，微笑着面对幸福，不言不语，携手同行。 </p><p>&emsp;&emsp;我拒绝被爱炙伤，拒绝让激情疯狂燃烧后，苍白的灰烬被失望的冬季耗尽青春的余温。</p><p>&emsp;&emsp;拒绝肤浅，接纳深沉。拒绝憎恶，接纳宽容、关怀和容忍。拒绝虚伪，接纳真诚。拒绝假、恶、丑，接纳真、善、美…… </p><p>&emsp;&emsp;生活中，一条充满诱惑的大路在脚下延伸着，只有学会拒绝才不会步入歧途。</p>]]></content>
    
    
    <summary type="html">好文分享</summary>
    
    
    
    
    <category term="文章" scheme="https://amireuxxf.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://amireuxxf.github.io/posts/4a17b156/"/>
    <id>https://amireuxxf.github.io/posts/4a17b156/</id>
    <published>2022-08-19T12:07:01.882Z</published>
    <updated>2022-08-30T00:43:55.205Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
