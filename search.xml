<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java知识点-SE篇</title>
      <link href="/posts/9b28f329/"/>
      <url>/posts/9b28f329/</url>
      
        <content type="html"><![CDATA[<h3 id="1-面向对象特性？"><a href="#1-面向对象特性？" class="headerlink" title="1.面向对象特性？"></a>1.面向对象特性？</h3><ul><li><strong>封装</strong><br>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。<br>优点:<ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li><li><strong>继承</strong><br>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。<br>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</li><li><strong>多态</strong><br>多态分为编译时多态和运行时多态:</li><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件:</li><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul></li></ul><h3 id="2-对equals-和hashCode-的理解"><a href="#2-对equals-和hashCode-的理解" class="headerlink" title="2.对equals()和hashCode()的理解?"></a>2.对equals()和hashCode()的理解?</h3><ul><li><strong>为什么在重写 equals 方法的时候需要重写 hashCode 方法</strong>?<br>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</li><li><strong>有没有可能两个不相等的对象有相同的 hashcode</strong>?<br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</li><li><strong>两个相同的对象会有不同的 hash code 吗</strong>?<br>不能，根据 hash code 的规定，这是不可能的。</li></ul><h3 id="3-String、StringBuffer与StringBuilder的区别？"><a href="#3-String、StringBuffer与StringBuilder的区别？" class="headerlink" title="3.String、StringBuffer与StringBuilder的区别？"></a>3.String、StringBuffer与StringBuilder的区别？</h3><ul><li>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</li><li>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</li></ul><h3 id="4-接口与抽象类的区别？"><a href="#4-接口与抽象类的区别？" class="headerlink" title="4.接口与抽象类的区别？"></a>4.接口与抽象类的区别？</h3><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li><li>抽象类可以有构造方法, 接口没有构造方法</li><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li></ul><h3 id="5-this-amp-super-在构造方法中的区别？"><a href="#5-this-amp-super-在构造方法中的区别？" class="headerlink" title="5.this() &amp; super()在构造方法中的区别？"></a>5.this() &amp; super()在构造方法中的区别？</h3><ul><li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li><li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li><li>尽管可以用this调用一个构造器, 却不能调用2个</li><li>this和super不能出现在同一个构造器中, 否则编译不通过</li><li>this()、super()都指的对象,不可以在static环境中使用</li><li>本质this指向本对象的指针。super是一个关键字</li></ul><h3 id="6-Break和continue和return有什么区别？"><a href="#6-Break和continue和return有什么区别？" class="headerlink" title="6.Break和continue和return有什么区别？"></a>6.Break和continue和return有什么区别？</h3><ul><li>break是结束循环。</li><li>continue是跳过本次循环，执行下一次循环。</li><li>return的作用不是结束循环，而是结束方法。</li></ul><h3 id="7-什么是方法重载（Overload）方法重写（Override）？"><a href="#7-什么是方法重载（Overload）方法重写（Override）？" class="headerlink" title="7.什么是方法重载（Overload）方法重写（Override）？"></a>7.什么是方法重载（Overload）方法重写（Override）？</h3><ul><li>方法重载：在同一个类中，具有相同的方法名， 参数列表不同（参数的个数及类型不同），与返回值无关。</li><li>方法重写：在子类中出现与父类一模一样的方法，返回值类型，方法名和参数列表都相同，会出现覆盖的效果，叫做方法的重写或复写。（声明不变，重新实现）</li></ul><h3 id="8-选择排序，冒泡排序原理？"><a href="#8-选择排序，冒泡排序原理？" class="headerlink" title="8.选择排序，冒泡排序原理？"></a>8.选择排序，冒泡排序原理？</h3><ul><li>选择排序：用第一个元素和每一个元素进行比较，从0索引开始，依次和后面元素比较，小的放前面，第一次完毕，最小值出现在最小索引处。</li><li>冒泡排序：相邻元素两两比较，大的往后放，第一次比较结束，最大值出现在最大索引处。</li></ul><h3 id="9-Java中继承的特点？"><a href="#9-Java中继承的特点？" class="headerlink" title="9.Java中继承的特点？"></a>9.Java中继承的特点？</h3><ul><li>java只能单继承不能多继承但可以多层继承，即间接继承；</li><li>子类默认拥有父类所有的非私有成员变量及方法；</li><li>一个类只能有一个父类，但一个父类可以有多个子类。</li></ul><h3 id="10-继承中成员变量、成员方法如何访问？"><a href="#10-继承中成员变量、成员方法如何访问？" class="headerlink" title="10.继承中成员变量、成员方法如何访问？"></a>10.继承中成员变量、成员方法如何访问？</h3><ul><li>子类可以直接访问父类中的非私有成员变量和方法；</li><li>出现同名的成员变量或方法时，在子类要访问父类的非私有成员变量或方法需要用 super引用；</li><li>构造方法不会被继承，子类初始化对象数据时一定会先调用父类的无参构造。</li></ul><h3 id="11-多态的好处和弊端（如何解决）？"><a href="#11-多态的好处和弊端（如何解决）？" class="headerlink" title="11.多态的好处和弊端（如何解决）？"></a>11.多态的好处和弊端（如何解决）？</h3><ul><li>好处：提高程序的扩展性，有更好的维护性（增加新子类不影响已存在类的多态性、继承性及其他操作）</li><li>弊端：不能使用子类特有的成员。</li><li>解决弊端：向下转型。</li></ul><h3 id="12-静态代码块的特点？"><a href="#12-静态代码块的特点？" class="headerlink" title="12.静态代码块的特点？"></a>12.静态代码块的特点？</h3><ul><li>给类变量（静态变量）进行初始化赋值</li><li>随着类的加载而执行且只执行一次，并且优先级高于main方法和构造方法。</li></ul><h3 id="13-静态成员变量和成员变量的区别？"><a href="#13-静态成员变量和成员变量的区别？" class="headerlink" title="13.静态成员变量和成员变量的区别？"></a>13.静态成员变量和成员变量的区别？</h3><ul><li>所属不同。静态成员变量属于类，成员变量属于对象。</li><li>内存位置不同。静态成员变量存在于静态区，成员变量存在于堆内存。</li><li>内存出现时间不同。静态成员变量随着类的加载而加载，且只加载一次，成员变量随对象的创建而存在。</li><li>调用不同。静态成员变量可以被类和对象调用，成员变量只能被对象调用。</li></ul><h3 id="14-多态的前提？"><a href="#14-多态的前提？" class="headerlink" title="14.多态的前提？"></a>14.多态的前提？</h3><ul><li>要有继承或实现关系</li><li>要有方法的重写</li><li>要有父类引用指向子类对象</li></ul><h3 id="15-throws和throw的区别？"><a href="#15-throws和throw的区别？" class="headerlink" title="15.throws和throw的区别？"></a>15.throws和throw的区别？</h3><ul><li>throw代表抛出一个异常的动作，throws代表可能有异常抛出的一种状态。</li><li>throw用在方法实现中，throws用在方法声明中。</li><li>throw只能用于抛出一种异常，throws可以抛出多个异常。</li></ul><h3 id="16-Finally有什么特点？"><a href="#16-Finally有什么特点？" class="headerlink" title="16.Finally有什么特点？"></a>16.Finally有什么特点？</h3><ul><li>在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</li><li>finally不能单独使用。必须配合着try…catch使用。</li><li>如果catch中有return语句，先执行finally中的代码，再执行return语句。</li></ul><h3 id="17-List集合有什么特点？List有3个子类，特点？"><a href="#17-List集合有什么特点？List有3个子类，特点？" class="headerlink" title="17.List集合有什么特点？List有3个子类，特点？"></a>17.List集合有什么特点？List有3个子类，特点？</h3><ul><li>有序可重复</li><li>ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高。</li><li>LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高。</li><li>Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低。</li></ul><h3 id="18-数组和集合有什么区别？"><a href="#18-数组和集合有什么区别？" class="headerlink" title="18.数组和集合有什么区别？"></a>18.数组和集合有什么区别？</h3><ul><li>数组长度固定，集合长度可变。</li><li>数组存储同一类型的元素，可以存储基本数据类型值。</li><li>集合存储的是对象，类型可以不一致，不能存放基本数据类型。</li></ul><h3 id="19-Final-finally，finalize区别？"><a href="#19-Final-finally，finalize区别？" class="headerlink" title="19.Final finally，finalize区别？"></a>19.Final finally，finalize区别？</h3><ul><li>final:是修饰符，修饰类，类不能被继承；修饰变量，不能被重新赋值，变成常量；修饰方法，方法不能被重写。</li><li>finally:是异常处理的一部分，用于释放资源。finally中的代码一定会被执行，特殊情况，在执行finally之前jvm退出。</li><li>finalize:是object类的一个方法，用于垃圾回收。</li></ul><h3 id="20-HashSet如何保证数据唯一性？"><a href="#20-HashSet如何保证数据唯一性？" class="headerlink" title="20.HashSet如何保证数据唯一性？"></a>20.HashSet如何保证数据唯一性？</h3><ul><li>通过hashCode()和equals()方法</li><li>先看hashCode()值是否相同</li><li>相同：继续equals()方法，<br>返回true：元素重复，不添加；<br>返回false：元素不重复，添加</li><li>不同：直接添加</li></ul><h3 id="21-hashMap和hashTable的区别？"><a href="#21-hashMap和hashTable的区别？" class="headerlink" title="21.hashMap和hashTable的区别？"></a>21.hashMap和hashTable的区别？</h3><ul><li>hashMap：线程不安全，效率高，允许null键和null值。</li><li>hashTable：线程安全，效率低，不允许null键和null值。</li></ul><h3 id="22-Collection-和-collections有什么区别？"><a href="#22-Collection-和-collections有什么区别？" class="headerlink" title="22.Collection 和 collections有什么区别？"></a>22.Collection 和 collections有什么区别？</h3><ul><li>collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法，collection接口在Java类库中有很多具体的体现，意义是为各种具体的集合提供了最大化的统一操作方式。</li><li>collections是一个操作集合的工具类，包含各种有关集合操作的静态多态方法，不能实例化，服务于Java的collection框架。</li></ul><h3 id="23-什么是递归？写递归要注意什么？"><a href="#23-什么是递归？写递归要注意什么？" class="headerlink" title="23.什么是递归？写递归要注意什么？"></a>23.什么是递归？写递归要注意什么？</h3><ul><li>递归是在自己的方法内调用自己。</li><li>递归一定要有条件限制，保证递归能够停止，否则会发生栈内存溢出。</li><li>递归次数不能太多，否则也会发生栈内存溢出。</li><li>构造方法禁止递归，构造方法是创建对象使用的，不能让对象一直创建下去。</li></ul><h3 id="24-和-eques的区别？"><a href="#24-和-eques的区别？" class="headerlink" title="24.== 和 eques的区别？"></a>24.== 和 eques的区别？</h3><ul><li>==是运算符，如果是基本数据类型，比较存储的值，如果是引用数据类型，比较所指对象的地址值（是否为同一个类）。</li><li>equals是object的方法，比较所指对象的地址值，重写之后比较对象的值。</li></ul><h3 id="25-IO流中的flush和close有什么区别？"><a href="#25-IO流中的flush和close有什么区别？" class="headerlink" title="25.IO流中的flush和close有什么区别？"></a>25.IO流中的flush和close有什么区别？</h3><ul><li>close();关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可以继续使用。</li><li>flush();仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。</li></ul><h3 id="26-Thread类和runable接口有什么区别？"><a href="#26-Thread类和runable接口有什么区别？" class="headerlink" title="26.Thread类和runable接口有什么区别？"></a>26.Thread类和runable接口有什么区别？</h3><ul><li>Runnable接口可以避免单继承的局限性，具有较强的健壮性。</li><li>Runnable可以实现资源的共享，同时处理同一资源。</li><li>Thread类的线程间都是独立运行的，资源不共享。</li><li>继承Thread类不再被其他类继承（Java不存在多继承）</li></ul><h3 id="27-什么是线程安全？如何判断一个程序是否会出现线程安全呢？"><a href="#27-什么是线程安全？如何判断一个程序是否会出现线程安全呢？" class="headerlink" title="27.什么是线程安全？如何判断一个程序是否会出现线程安全呢？"></a>27.什么是线程安全？如何判断一个程序是否会出现线程安全呢？</h3><ul><li>多线程执行的结果和单线程运行的结果一样，就是线程安全的。</li><li>是否有共享资源   是</li><li>是否有多条执行路径   是</li><li>是否这多条路径操作共享资源   是</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 信息技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我拒绝向岁月祈求</title>
      <link href="/posts/ddfda2a8/"/>
      <url>/posts/ddfda2a8/</url>
      
        <content type="html"><![CDATA[<p>行走于世间，接纳或拒绝，爱或不爱，放弃或执著…… 每个人都应有接纳与宽容之心，但也要学会拒绝。 </p><p>我拒绝麻木。虽然生活的磨砺让太多的热情化做烟云，但不能让感情磨出老茧。如果没有云让眼神放飞追逐，那么生还有什么乐趣？ </p><p>我拒绝永远明媚的日子。因为那是虚幻的梦境，痛苦可以让我成长、让我坚强。生活中的阴雨与风雪使我能清醒地在春梦中看清脚下的路。</p><p>我拒绝折下那朵盛开的小花，那是在毁灭美的生命。一枝脆弱的纤细花茎，经过多少挣扎与痛苦才盛开出美丽，怎忍心为个人的私欲而去毁灭别人的幸福。我只求远远地望着，默默祈祷那自然的奇迹开遍人生的每个角落。</p><p>我拒绝用青春去赌明天。那弥足珍贵的季节，怎能经得起一掷千金，千金可以收回，但无论是一小时、一分钟……失去了便无处可寻了。青春属于自己，把握它，运用它，珍惜它，才能收获金秋的硕果。 </p><p>我拒绝成为那窗台上惧怕风雨的温柔花，它们只能隔着玻璃窗，感叹多变的天气。有朝一日，有风从虚掩的窗户掠过，那娇弱的花朵便瓣瓣凋零，落一地遗憾和伤心。 </p><p>我欣赏那些与男人并肩的女性，凭自己的聪慧和魅力，得到世界的尊重和生活的地位。我欣赏那有几分豪气的女人，靠自己的双肩挑起生活重担，出得厅堂，下得厨房，卷起袖子能杀鸡宰羊，却也有万缕柔肠能营造一片温馨。 </p><p>我拒绝生活中的痛苦，虽然我无力去阻挡要降临的事。 </p><p>曾听过一个故事：有人去找禅师求得解脱痛苦的方法，禅师让他自己去悟。第一天，禅师问他悟到什么，他不知，便举起戒尺打他一下。<br>第二天，禅师又问，他仍不知，禅师举起戒尺又打了他一下。第三天他仍然没有收获，当禅师举手要打时，他却挡住了。于是禅师笑道：“你终于悟出了这道理——拒绝痛苦。”</p><p>我拒绝为满足虚荣、得到金钱与地位而不惜以青春、美丽甚至感情为祭品。人生中充满诱惑，也同样遍布着歧途与陷阱，女人的美丽是自然的恩赐，是真、善、美的化身，宛如一块无瑕的美玉，决不能被世俗污染，女人要靠自己的能力与才智取得应有的地位和尊重。</p><p>我拒绝倾听罗密欧与朱丽叶式的故事。虽然他们爱得壮烈，但终究是悲剧的结局。我只求现实中的爱有一点浪漫，有几缕微风，有短暂的雷雨也无妨，始终是平淡而幸福的喜剧。</p><p>我拒绝向岁月祈求，流着泪埋怨时光的无情。</p><p>虽然，青春已无声地在日历中一页页翻飞不见了，生活已把经历写在我的眼角，染白长长的青丝，但我相信女人的青春在于她的心境。美丽易逝，魅力永存。 </p><p>我拒绝目的明确的爱情。爱是无法用语言说明的，一段让人辗转难眠、牵肠挂肚、见面时又相对无言的情感遭遇，经过多少欢笑与泪水、缠绵与零落，只为表达一个难以启齿的字——爱。我喜欢平静地望着爱人眼中的自己，微笑着面对幸福，不言不语，携手同行。 </p><p>我拒绝被爱炙伤，拒绝让激情疯狂燃烧后，苍白的灰烬被失望的冬季耗尽青春的余温。</p><p>拒绝肤浅，接纳深沉。拒绝憎恶，接纳宽容、关怀和容忍。拒绝虚伪，接纳真诚。拒绝假、恶、丑，接纳真、善、美…… </p><p>生活中，一条充满诱惑的大路在脚下延伸着，只有学会拒绝才不会步入歧途。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
